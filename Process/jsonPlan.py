import json
from Process.RTplan import *
import requests
import csv

'''
Class to 1) convert openTPS plan into json plan (input for scanAlgo) 
         2) Compute Beam Delivery Time (BDT) based on scanAlgo output

Usage:

from Process.jsonPlan import *

# load OpenTPS plan
file_path = "Plan_OpenTPS.tps"
plan = RTplan()
plan.load(file_path)

# Create BDT object
BDT = BDT(plan)
# Create 1 json file per beam
jsonFiles = BDT.create_jsonFiles()
# call scanAlgo to get times (in ms)
BDT.call_scanAlgo(jsonFiles)
# create inputCSV for arcAlgo
BDT.create_inputCSV("yo.csv")


'''


class BDT:
    def __init__(self,plan, config):
        self.openTPSPlan = plan
        self.params = self.get_config_params(config)
        self.Gantry = self.params['Gantry']
        self.url = self.params['Gateway']
        self.inputCSV = []

                
    def create_jsonFiles(self, sort_spots="true"):
        jsonFiles = []
        for i,beam in enumerate(self.openTPSPlan.Beams):
            jsonPlan = JsonPlan(self.openTPSPlan, self.Gantry,i, sort_spots=sort_spots)
            filename = "beam_" + str(i) + ".json"
            jsonPlan.save(filename)
            jsonFiles.append(filename)
        return jsonFiles


    def get_config_params(self,config):
        with open(config) as f:
            lines = f.readlines()
            columns = []
            i = 1
            d = {}
            for line in lines:
                if line.strip():
                    line = line.strip().split(',')# remove leading/trailing white spaces
                    key  = line[0].strip()
                    value  = line[1].strip()
                    d[key]=value
        return d


    def call_scanAlgo(self,jsonFilesList):
        previous_energy = 0
        for index,beam in enumerate(jsonFilesList):
            with open(beam,'rb') as f:
                data = json.load(f)
            gantry_angle = data['gantryangle']
            scanAlgo = requests.post(self.url,json=data).json()
            if 'cause' in scanAlgo:
               print("!!!!!!!!! ScanAlgo ERROR in beam !!!!!!! ", index)  
               print('\n')
               print(scanAlgo['cause'])
               print('\n')
            else:
                print('BDT {}  = {} '.format(index,scanAlgo['layer'][-1]['spot'][-1]['start']))
                print('\n')
                angle_time = 300 + (scanAlgo['layer'][-1]['spot'][-1]['start'] + scanAlgo['layer'][-1]['spot'][-1]['duration'] - scanAlgo['layer'][0]['spot'][0]['start'])
                beam_csv = []
                if previous_energy == 0:
                    beam_csv.append(str(gantry_angle))
                    beam_csv.append(str(angle_time))
                    beam_csv.append(str('NA'))
                elif scanAlgo['layer'][0]['energy'] < previous_energy:
                    beam_csv.append(str(gantry_angle))
                    beam_csv.append(str(angle_time))
                    beam_csv.append(str('Down'))
                else:
                    beam_csv.append(str(gantry_angle))
                    beam_csv.append(str(angle_time))
                    beam_csv.append(str('Up'))
                previous_energy = scanAlgo['layer'][-1]['energy']
                self.inputCSV.append(beam_csv)
        
    def create_inputCSV(self,inputCSV_filename):
        header = ['Angle','Time','Switch']
        with open(inputCSV_filename, 'w') as f:
            # create the csv writer
            writer = csv.writer(f)    
            # write the header
            writer.writerow(header)
            writer.writerows(self.inputCSV)
        
    def call_arcAlgo(self, input_CSV_filename, config):
        pass


    def get_PBS_timings(self, jsonFilesList):
        """
        Add timings for each spot in the plan:
        INPUT:
            jsonFilesList: list of json files (one for each beam) generated by create_jsonFiles
        OUTPUT:
            RTplan with timings
        """
        plan = self.openTPSPlan.copy()
        gantry_angles = [] if plan.Beams==[] else [plan.Beams[i].GantryAngle for i in range(len(plan.Beams))]
        for index,beam in enumerate(jsonFilesList):
            with open(beam,'rb') as f:
                data = json.load(f)
            gantry_angle = float(data['gantryangle']) if self.Gantry=="PPlus" else float(data['gantryAngle'])
            scanAlgo = requests.post(self.url,json=data).json()
            if 'cause' in scanAlgo:
               print("!!!!!!!!! ScanAlgo ERROR in beam !!!!!!! ", index)  
               print('\n')
               print(scanAlgo['cause'])
               print('\n')
            else:
                if self.Gantry == "PPlus":
                    index_beam = np.where(np.array(gantry_angles)==gantry_angle)[0][0]
                    plan = self.parse_pplus_response(plan, scanAlgo, index_beam)
                elif self.Gantry == "POne":
                    index_beam = np.where(np.array(gantry_angles)==gantry_angle)[0][0]
                    plan = self.parse_pone_response(plan, scanAlgo, index_beam)
                else:
                    raise Exception(f'Unknown gantry type {self.Gantry}')

        return plan


    def parse_pplus_response(self, plan, scanAlgo, index_beam):
        """
        Parse response from ScanAlgo for PPlus gantry + reorder spots according to spot timings
        INPUTS:
            plan: RTplan
            scanAlgo: output from scanAlgo
            index_beam: index number of the beam in plan.Beams
        OUTPUT:
            RTplan with timings
        """
        assert len(plan.Beams[index_beam].Layers) == len(scanAlgo['layer'])
        assert plan.Beams[index_beam].Layers[0].SpotTiming == []
        for l in range(len(plan.Beams[index_beam].Layers)):
            # identify current spot in layer
            for s in range(len(plan.Beams[index_beam].Layers[l].ScanSpotPositionMap_x)):
                index_spot_scanAlgo = self.find_spot_index_json(scanAlgo['layer'][l]['spot'], 
                    plan.Beams[index_beam].Layers[l].ScanSpotPositionMap_x[s],
                    plan.Beams[index_beam].Layers[l].ScanSpotPositionMap_y[s])
                start_time = float(scanAlgo['layer'][l]['spot'][index_spot_scanAlgo]['start']) / 1000
                plan.Beams[index_beam].Layers[l].SpotTiming.append(start_time)
            # Reorder spots according to spot timings
            order = np.argsort(plan.Beams[index_beam].Layers[l].SpotTiming)
            plan.Beams[index_beam].Layers[l].reorder_spots(order)
        return plan



    def parse_pone_response(self, plan, scanAlgo, index_beam):
        """
        Parse response from ScanAlgo for POne gantry + reorder spots according to spot timings
        Since there is an intrinsec rescanning for the POne, the plan is modified accordingly, i.e.
            - Spots are added in the plan corresponding to the rescanning
            - SpotMU are weighted according to the dose delivered in each burst
        Timings are computed with postprocessing (i.e. layer time, burst time accumulation)
        INPUTS:
            plan: RTplan
            scanAlgo: output from scanAlgo
            index_beam: index number of the beam in plan.Beams
        OUTPUT:
            RTplan with timings
        """
        assert len(plan.Beams[index_beam].Layers) == len(scanAlgo['layers'])
        assert plan.Beams[index_beam].Layers[0].SpotTiming == []
        burst_switching_time = 150
        cumul_layer_time = 0
        for l in range(len(plan.Beams[index_beam].Layers)):
            assert 'bursts' in scanAlgo['layers'][l]
            max_num_bursts = len(scanAlgo['layers'][l]['bursts'])
            cumul_layer_time += float(scanAlgo['layers'][l]["switchingTime"])
            num_spots = len(plan.Beams[index_beam].Layers[l].SpotMU)
            # Initialize spot timings array with dummy values (-1)
            plan.Beams[index_beam].Layers[l].SpotTiming = list(-1*np.ones(num_spots))

            for s in range(num_spots):
                index_spot_scanAlgo = []
                charge_spot_all_bursts = []
                total_charge = 0
                for b in range(max_num_bursts):
                    index_spot_scanAlgo.append(self.find_spot_index_json(scanAlgo['layers'][l]['bursts'][b]['spots'], 
                        plan.Beams[index_beam].Layers[l].ScanSpotPositionMap_x[s],
                        plan.Beams[index_beam].Layers[l].ScanSpotPositionMap_y[s]))
                    if index_spot_scanAlgo[-1] is not None:
                        charge_spot_all_bursts.append(float(scanAlgo['layers'][l]['bursts'][b]['spots'][index_spot_scanAlgo[-1]]['targetCharge']))
                        total_charge += charge_spot_all_bursts[-1]
                    else:
                        charge_spot_all_bursts.append(None)

                partial_MU = [c/total_charge if c is not None else None for c in charge_spot_all_bursts]
                first_non_None_burst_index = next(i for i in range(len(index_spot_scanAlgo)) if index_spot_scanAlgo[i] is not None)

                cumul_burst_time = 0
                for t in range(first_non_None_burst_index):
                    cumul_burst_time += scanAlgo['layers'][l]['bursts'][t]['spots'][-1]["startTime"] + \
                        scanAlgo['layers'][l]['bursts'][t]['spots'][-1]["duration"] + burst_switching_time

                start_time = float(scanAlgo['layers'][l]['bursts'][first_non_None_burst_index]['spots'][index_spot_scanAlgo[first_non_None_burst_index]]['startTime']) + \
                    cumul_layer_time + cumul_burst_time
                plan.Beams[index_beam].Layers[l].SpotTiming[s] = start_time / 1000
                # Adapt MU from intrinsec rescanning (MU proportional to bursts charges)
                spot_MU = plan.Beams[index_beam].Layers[l].SpotMU[s]
                spot_weights = plan.Beams[index_beam].Layers[l].ScanSpotMetersetWeights[s]
                plan.Beams[index_beam].Layers[l].SpotMU[s] = spot_MU * partial_MU[first_non_None_burst_index]
                plan.Beams[index_beam].Layers[l].ScanSpotMetersetWeights[s] = spot_weights * partial_MU[first_non_None_burst_index]

                cumul_burst_time += scanAlgo['layers'][l]['bursts'][first_non_None_burst_index]['spots'][-1]["startTime"] + scanAlgo['layers'][l]['bursts'][first_non_None_burst_index]['spots'][-1]["duration"] + burst_switching_time

                if first_non_None_burst_index + 1 < max_num_bursts:
                    for b in range(first_non_None_burst_index+1, max_num_bursts):
                        if index_spot_scanAlgo[b] is not None:
                            plan.Beams[index_beam].Layers[l].ScanSpotPositionMap_x.append(plan.Beams[index_beam].Layers[l].ScanSpotPositionMap_x[s])
                            plan.Beams[index_beam].Layers[l].ScanSpotPositionMap_y.append(plan.Beams[index_beam].Layers[l].ScanSpotPositionMap_y[s])
                            plan.Beams[index_beam].Layers[l].SpotMU.append(spot_MU*partial_MU[b])
                            plan.Beams[index_beam].Layers[l].ScanSpotMetersetWeights.append(spot_weights*partial_MU[b])
                            start_time = float(scanAlgo['layers'][l]['bursts'][b]['spots'][index_spot_scanAlgo[b]]['startTime']) + \
                                cumul_layer_time + cumul_burst_time
                            plan.Beams[index_beam].Layers[l].SpotTiming.append(start_time / 1000)
                            cumul_burst_time += scanAlgo['layers'][l]['bursts'][b]['spots'][-1]["startTime"] + scanAlgo['layers'][l]['bursts'][b]['spots'][-1]["duration"] + burst_switching_time
            
            # Reorder spots according to spot timings
            order = np.argsort(plan.Beams[index_beam].Layers[l].SpotTiming)
            plan.Beams[index_beam].Layers[l].reorder_spots(order)
            cumul_layer_time += float(scanAlgo['layers'][l]["duration"])
            cumul_burst_time = 0 # initialize to zero for next layer
        return plan




    def find_spot_index_json(self, json_arr, pos_x, pos_y):
        """
        Find index of spot corresposding to position (pos_x,pos_y) in JSON file
        """
        if self.Gantry=="PPlus":
            pos_x_name = 'clinicalx'
            pos_y_name = 'clinicaly'
        else: # self.Gantry=="POne"
            pos_x_name = 'clinicalX'
            pos_y_name = 'clinicalY'
        for i in range(len(json_arr)):
            if np.isclose(float(json_arr[i][pos_x_name]), float(pos_x)) and np.isclose(float(json_arr[i][pos_y_name]), float(pos_y)):
                return i
        return None
        #print('No match between position of scanAlgo output and original plan found.')



class JsonPlan:
    def __init__(self, plan, Gantry = "PPlus", beamID = 0, sort_spots="true"):
        beam = plan.Beams[beamID]
        if Gantry == "PPlus":
            self.bsp = "GTR1-PBS"
            self.sort = sort_spots
            self.snoutextension = "430"
            self.gantryangle = str(beam.GantryAngle)
            self.rangeshifterid = str(beam.RangeShifterID)
            self.ridgefilterid = ""
            self.rangecompensatorid = ""
            self.blockid = ""
            self.snoutid = ""
            self.actualtemperature = "293.15"
            self.referencetemperature = "293.15"
            self.actualpressure = "1030"
            self.referencepressure = "1030"
            self.dosecorrectionfactor = "1"
            self.ic23offsetx = "0"
            self.ic23offsety = "0"
            self.smoffsetx = "0"
            self.smoffsety = "0" 
            self.ic1positionx = "0"
            self.ic1positiony = "0"
        elif Gantry == "POne":
            self.beamSupplyPointId = "CGTR"
            self.sortSpots = sort_spots
            self.snoutExtension = "430"
            self.gantryAngle = beam.GantryAngle
            self.beamGatingRequired = "false"
            self.rangeShifterId = str(beam.RangeShifterID)
            self.ridgeFilterId = ""
            self.rangeCompensatorId = ""
            self.blockId = ""
            self.snoutId = ""
            self.actualTemperature = "20.0"
            self.referenceTemperature = "20.0"
            self.actualPressure = "101.325"
#file_path = "data/Phantoms/phantom_3mm/OpenTPS/Plan_phantom_1mm_9Beams_LS5_SS5_RTV7-5_Mai-26-2021_09-48-33.tps"
            self.referencePressure = "101.325"
            self.doseCorrectionFactor = "1"
            self.icOffsetX = "0"
            self.icOffsetY = "0"
            self.smOffsetX = "0"
            self.smOffsetY = "0" 
            self.ic1PositionX = "0"
            self.ic1PositionY = "0"

        self.mud = "0"
        
        self.beam = self.getLayers(plan,Gantry,beamID)

    def getLayers(self,plan,Gantry,beamID):
        beam = plan.Beams[beamID]
        beamDict = {}
        if Gantry == "PPlus":
            beamDict['mu'] = str(beam.BeamMeterset) 
            beamDict['repaintingtype'] = "None"
            beamDict['layer'] = []
            for layer in beam.Layers:
                layerDict = {}
                layerDict['spottuneid'] = "3.0"
                layerDict['energy'] = str(layer.NominalBeamEnergy)
                layerDict['paintings'] = str(layer.NumberOfPaintings)
                layerDict['spot'] = []
                for s in range(len(layer.SpotMU)):
                    spotDict = {}
                    spotDict['x'] = str(layer.ScanSpotPositionMap_x[s])
                    spotDict['y'] = str(layer.ScanSpotPositionMap_y[s])
                    spotDict['metersetweight'] = str(layer.SpotMU[s])
                    #spotDict['metersetweight'] = str(layer.ScanSpotMetersetWeights[s])
                    layerDict['spot'].append(spotDict)
                beamDict['layer'].append(layerDict)
        elif Gantry == "POne":
            beamDict['meterset'] = beam.BeamMeterset
            beamDict['repaintingType'] = "None"
            beamDict['layers'] = []
            for layer in beam.Layers:
                layerDict = {}
                layerDict['spotTuneId'] = "4.0"
                layerDict['nominalBeamEnergy'] = layer.NominalBeamEnergy
                layerDict['numberOfPaintings'] = layer.NumberOfPaintings
                layerDict['spots'] = []
                for s in range(len(layer.SpotMU)):
                    spotDict = {}
                    spotDict['positionX'] = layer.ScanSpotPositionMap_x[s]
                    spotDict['positionY'] = layer.ScanSpotPositionMap_y[s]
                    spotDict['metersetWeight'] = layer.SpotMU[s]
                    layerDict['spots'].append(spotDict)
                beamDict['layers'].append(layerDict)
        return beamDict

    def save(self, file_path):
        with open(file_path, 'w') as fid:
            json.dump(self.__dict__,fid)

    def load(self,file_path):
        with open(file_path) as fid:
            self.data = json.load(fid)
            



